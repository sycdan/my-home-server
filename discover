#!/usr/bin/env python
"""
Device discovery initializer.
Generates RouterOS scripts for each device and deploys them to the router.
Loads configuration from .env files.
"""

import argparse
import json
import os
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List

ROOT_DIR = Path(__file__).resolve().parent
DEVICE_SCRIPT_CACHE_DIR = ROOT_DIR / ".device-scripts"
FLEET_FILE = ROOT_DIR / "fleet.json"
EXAMPLE_ENV_FILE = ROOT_DIR / "example.env"
ENV_FILE = ROOT_DIR / ".env"


def ensure_env_file() -> None:
  if not ENV_FILE.exists():
    ENV_FILE.write_text(EXAMPLE_ENV_FILE.read_text())
    print(
      f"Created default .env file at {ENV_FILE}. Customize it as necessary, then rerun."
    )
    sys.exit(0)


def load_env_file(filepath: Path) -> dict[str, str]:
  env_vars = {}
  if not filepath.exists():
    return env_vars

  for line in filepath.read_text().splitlines():
    line = line.strip()
    # Skip empty lines and comments
    if not line or line.startswith("#"):
      continue
    # Parse KEY=VALUE
    if "=" in line:
      key, value = line.split("=", 1)
      env_vars[key.strip()] = value.strip()

  return env_vars


def load_config(source_dir: Path) -> dict[str, str]:
  """Load configuration from service .env file with environment variable overrides."""
  config = load_env_file(source_dir / ".env")

  # Environment variables override .env values
  for key in config:
    if key in os.environ:
      config[key] = os.environ[key]

  return config


ensure_env_file()
CONFIG = load_config(ROOT_DIR)
ROUTER_SSH_HOST = CONFIG["ROUTER_SSH_HOST"]
SCHEDULE_INTERVAL = CONFIG["SCHEDULE_INTERVAL"]
DOMAIN_SUFFIX = CONFIG["DOMAIN_SUFFIX"]

# Colors for output
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
NC = "\033[0m"  # No Color


def print_info(msg: str) -> None:
  """Print status message in blue"""
  print(f"{BLUE}► {NC} {msg}")


def print_success(msg: str) -> None:
  """Print success message in green"""
  print(f"{GREEN}✓ {NC} {msg}")


def print_warning(msg: str) -> None:
  """Print warning message in yellow to stderr"""
  print(f"{YELLOW}⚠ {NC} {msg}", file=sys.stderr)


def print_error(msg: str) -> None:
  """Print error message in red to stderr"""
  print(f"{RED}✗ {NC} {msg}", file=sys.stderr)


@dataclass
class Device:
  host: str
  primary_mac: str
  secondary_mac: str
  description: str


def load_devices(devices_file: Path) -> List[Device]:
  """Load devices from devices.json file."""

  if not devices_file.exists():
    print_error(f"{devices_file} does not exist")
    return []

  try:
    data = json.loads(devices_file.read_text())
    devices: list[Device] = []

    for host, device_info in data.get("devices", {}).items():
      device = Device(
        host=host,
        primary_mac=device_info.get("primary_mac", ""),
        secondary_mac=device_info.get("secondary_mac", ""),
        description=device_info.get("description", ""),
      )
      devices.append(device)

    return devices
  except json.JSONDecodeError as e:
    print_error(f"Failed to parse devices.json: {e}")
    return []

  return devices


def escape_script(content: str) -> str:
  """
  Escape content for RouterOS script.
  RouterOS needs:
  1. Backslashes -> \\
  2. Quotes -> \"
  3. Dollar signs -> \\$
  4. Actual newlines -> \\n
  """
  # Order matters: backslashes first, then other escapes
  content = content.replace("\\", "\\\\")
  content = content.replace('"', '\\"')
  content = content.replace("$", "\\$")
  content = content.replace("\n", "\\n")
  return content


def run_ssh_command(
  hostname: str, command: str, identity_file: str = ""
) -> tuple[str, int]:
  """Run SSH command and return output and return code."""
  args = ["ssh", f"{hostname}"]
  if identity_file:
    args.extend(["-i", identity_file])
  args.extend(["-x", command])
  try:
    result = subprocess.run(
      args,
      capture_output=True,
      text=True,
      check=True,
    )
    return result.stdout, result.returncode
  except Exception as e:
    print_error(f"SSH command failed: {e}")
    return "", -1


def run_on_router(command: str) -> tuple[str, int]:
  return run_ssh_command(
    ROUTER_SSH_HOST,
    command,
  )


def upload_script(script_name: str, local_source: str, script_comment: str) -> bool:
  """Upload script to router."""
  print_info(f"Updating script '{script_name}' on {ROUTER_SSH_HOST}...")
  escaped_source = escape_script(local_source)

  # Remove old script
  run_on_router(f'/system script remove [find name="{script_name}"]')

  # Add new script
  run_on_router(
    f'/system script add name="{script_name}" source="{escaped_source}" comment="{script_comment}"',
  )
  print_success(f"Script '{script_name}' updated successfully")
  return True


def create_schedule(script_name: str, schedule_spec: str, user="admin") -> bool:
  """Set up a scheduler entry to run the script."""
  # Validate format: hh:mm:ss
  parts = schedule_spec.split(":")
  if len(parts) != 3:
    print_error(
      f"Invalid schedule format: '{schedule_spec}'. Expected hh:mm:ss (e.g., '00:05:00')"
    )
    return False

  try:
    hours = int(parts[0])
    minutes = int(parts[1])
    seconds = int(parts[2])
    if not (0 <= hours <= 23 and 0 <= minutes <= 59 and 0 <= seconds <= 59):
      raise ValueError()
  except (ValueError, IndexError):
    print_error(
      f"Invalid schedule format: '{schedule_spec}'. Hours must be 0-23, minutes 0-59, seconds 0-59"
    )
    return False

  schedule_name = f"{script_name}_schedule"

  # Remove existing schedule if it exists
  run_on_router(f'/system scheduler remove [find name="{schedule_name}"]')

  # Add new schedule
  run_on_router(
    f'/system scheduler add name="{schedule_name}" on-event="/system script run \\"{script_name}\\"" interval="{schedule_spec}"',
  )

  return True


def generate_device_discovery_script(
  hostname: str, primary_mac: str, secondary_mac: str
) -> str:
  """Generate a RouterOS script for a single device."""
  script = f"""# Updates DNS entry for {hostname}
# Generated by {__file__} service

:local hostname "{hostname}"
:local primaryMac "{primary_mac}"
:local secondaryMac "{secondary_mac}"

:local findReachableIp do={{
  # Try each MAC in order (earlier ones are more preferred)
  # Return the first reachable interface and its IP, or empty array if none are reachable
  :local macs $1
  :foreach mac in=$macs do={{
    :if ($mac != "") do={{
      :put "  Trying MAC $mac"
      :local leaseEntries [/ip dhcp-server lease find where active-mac-address=$mac]
      :if ([:len $leaseEntries] > 0) do={{
        :foreach leaseIndex in=$leaseEntries do={{
          :local lease [/ip dhcp-server lease get $leaseIndex]
          :local ip ($lease->"active-address")
          :put "    Pinging $ip"
          :local pingResult [/ping $ip count=1]
          :if ($pingResult > 0) do={{
            :put "    Ping succeeded"
            :return {{$ip; $mac}}
          }} else={{
            :put "    Ping failed"
          }}
        }}
      }} else={{
        :put "    No active DHCP lease found"
      }}
    }}
  }}
  :put "  No reachable address found"
  :return ""
}}

:local updateDnsEntry do={{
  :local hostname $1
  :local ip $2
  :local mac $3
  
  /ip dns static remove [find name=$hostname]
  /ip dns static add name=$hostname address=$ip comment="$mac [MHS]" ttl=5m
  :put "  DNS updated: $hostname -> $ip"
}}

:put "==== Discovering $hostname ===="

:local macs {{$primaryMac; $secondaryMac}}
:local result [$findReachableIp $macs]

:if ($result != "") do={{
  :local ip ($result->0)
  :local mac ($result->1)
  :put "Using IP $ip (MAC: $mac)"
  [$updateDnsEntry $hostname $ip $mac]
}} else={{
  :put "ERROR: Could not find reachable IP for $hostname"
}}

:put "==== Complete ===="
"""
  return script


def main(argv: List[str] | None = None) -> None:
  """Main entry point."""
  parser = argparse.ArgumentParser(
    description="Deploy device discovery scripts to router"
  )
  parser.add_argument(
    "--debug",
    action="store_true",
    help="Enable debug output",
  )
  args = parser.parse_args(argv)

  if args.debug:
    print_info(f"Using config: {CONFIG}")
    print_info(f"Fleet file: {FLEET_FILE}")

  DEVICE_SCRIPT_CACHE_DIR.mkdir(exist_ok=True)

  devices = load_devices(FLEET_FILE)
  if not devices:
    print_error(f"No devices configured in {FLEET_FILE}")
    sys.exit(1)

  deployed_count = 0
  failed_count = 0

  for device in devices:
    name = device.description.strip() or device.host
    hostname = f"{device.host}.{DOMAIN_SUFFIX}"
    print_info(f"Discovering {name} ({hostname})")

    script_name = f"discover-{device.host}"
    script_file = DEVICE_SCRIPT_CACHE_DIR / f"{script_name}.rsc"
    script_comment = f"Discover {name} ({hostname})"
    script_content = generate_device_discovery_script(
      hostname,
      device.primary_mac,
      device.secondary_mac,
    )
    try:
      script_file.write_text(script_content)
      print_info(f"Generated {script_file.relative_to(ROOT_DIR)}")
    except Exception as e:
      print_error(f"Failed to generate script for {name}: {e}")
      failed_count += 1
      continue

    # Deploy the script to the router
    if upload_script(script_name, script_content, script_comment):
      run_on_router(f'/system script run "{script_name}"')
      if create_schedule(script_name, SCHEDULE_INTERVAL):
        print_success(f"Deployed {script_name} to {ROUTER_SSH_HOST}")
        deployed_count += 1
      else:
        print_error(f"Failed to schedule {script_name}")
        failed_count += 1
    else:
      print_error(f"Failed to deploy {script_name}")
      failed_count += 1

  # Summary
  print()
  print_info("Deployment complete:")
  print_success(f"Deployed: {deployed_count} device(s)")
  if failed_count > 0:
    print_warning(f"Failed: {failed_count} device(s)")
    sys.exit(1)

  sys.exit(0)


if __name__ == "__main__":
  main()
