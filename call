#!/usr/bin/env python
import argparse
import importlib.util
import inspect
import json
import sys
from pathlib import Path
from types import ModuleType

from google.protobuf import json_format
from google.protobuf.descriptor import FieldDescriptor
from google.protobuf.message import Message

from mhs.output import print_error


def to_json(obj):
  try:
    if hasattr(obj, "DESCRIPTOR"):
      return json_format.MessageToDict(obj, preserving_proto_field_name=True)
  except ImportError:
    pass
  return obj


def locate_action_directory(action_path: Path | str) -> Path:
  """Locate the action directory given a path to either the directory or logic file."""
  if not isinstance(action_path, Path):
    action_path = Path(action_path)

  if not action_path.exists():
    print_error(f"Action path does not exist: {action_path}")
    sys.exit(1)

  if action_path.is_dir():
    logic_file = action_path / "logic.py"
    if not logic_file.exists():
      print_error(f"No logic.py file found in {action_path}")
      sys.exit(1)
    return action_path
  elif action_path.is_file() and action_path.name == "logic.py":
    return action_path.parent
  else:
    print_error(f"Invalid action path: {action_path}. Must be a directory or logic.py file.")
    sys.exit(1)


def load_logic_module(logic_path: Path):
  """Dynamically load a logic module from the given path."""
  if not logic_path.exists():
    print_error(f"Logic file not found: {logic_path}")
    sys.exit(1)
  spec = importlib.util.spec_from_file_location("logic_module", str(logic_path))
  if not spec or not spec.loader:
    print_error(f"Could not load logic module from {logic_path}")
    sys.exit(1)
  logic_module = importlib.util.module_from_spec(spec)
  spec.loader.exec_module(logic_module)
  return logic_module


def get_handler_function(logic_module: ModuleType, handler_name="handle"):
  handler = getattr(logic_module, handler_name, None)
  if handler is None:
    print_error(f"{logic_module.__file__} does not define an '{handler_name}' function.")
    sys.exit(1)
  return handler


def get_request_class(handler):
  sig = inspect.signature(handler)
  params = list(sig.parameters.values())
  if len(params) == 1 and params[0].annotation != inspect.Parameter.empty:
    request_class = params[0].annotation
    if issubclass(request_class, Message):
      return request_class
  print_error("Handler function must take a single Message parameter.")
  sys.exit(1)


def parse_bool(value: str):
  if isinstance(value, bool):
    return value

  true_values = {"true", "t", "1", "yes", "y", "on"}
  false_values = {"false", "f", "0", "no", "n", "off"}

  if isinstance(value, str):
    value_lower = value.strip().lower()
    if value_lower in true_values:
      return True
    elif value_lower in false_values:
      return False

  raise argparse.ArgumentTypeError(f"Invalid boolean value: {value}")


def build_request_parser(request_class: type[Message]):
  parser = argparse.ArgumentParser(description=f"Args for {request_class}", add_help=False)
  for field in request_class.DESCRIPTOR.fields:
    if field.type in (FieldDescriptor.TYPE_DOUBLE, FieldDescriptor.TYPE_FLOAT):
      parser.add_argument(f"--{field.name}", type=float)
    elif field.type in (
      FieldDescriptor.TYPE_INT64,
      FieldDescriptor.TYPE_UINT64,
      FieldDescriptor.TYPE_INT32,
      FieldDescriptor.TYPE_FIXED64,
      FieldDescriptor.TYPE_FIXED32,
      FieldDescriptor.TYPE_UINT32,
      FieldDescriptor.TYPE_SINT32,
      FieldDescriptor.TYPE_SINT64,
    ):
      parser.add_argument(f"--{field.name}", type=int)
    elif field.type == FieldDescriptor.TYPE_BOOL:
      parser.add_argument(f"--{field.name}", type=parse_bool)
    elif field.type == FieldDescriptor.TYPE_STRING:
      parser.add_argument(f"--{field.name}", type=str)
  return parser


def build_request_object(req_class: type[Message], req_args: argparse.Namespace):
  req_obj = req_class()
  for field_name, value in vars(req_args).items():
    if value is not None:
      setattr(req_obj, field_name, value)
  return req_obj


def main():
  parser = argparse.ArgumentParser(
    description="Entrypoint for dynamic action execution.",
    add_help=False,  # We'll handle help manually
  )
  parser.add_argument(
    "action_path", nargs="?", default="", help="Path to the action's directory or logic file."
  )
  parser.add_argument("-h", "--help", action="store_true", help="Show help message and exit.")
  args, remaining = parser.parse_known_args()

  # Show base help if no action_path is provided
  if not args.action_path:
    if args.help:
      parser.print_help()
    else:
      parser.print_usage()
    return

  action_dir = locate_action_directory(Path(args.action_path).resolve())
  logic_module = load_logic_module(action_dir / "logic.py")
  req_handler = get_handler_function(logic_module)
  req_class = get_request_class(req_handler)
  req_parser = build_request_parser(req_class)

  # Show action-specific help if requested
  if args.help:
    req_parser.prog = f"./call {args.action_path}"
    req_parser.print_help()
    return

  req_args = req_parser.parse_args(remaining)
  req_obj = build_request_object(req_class, req_args)
  response = req_handler(req_obj)
  print(json.dumps(to_json(response), indent=2))


if __name__ == "__main__":
  main()
