#!/usr/bin/env python
"""
Device discovery service initializer.
Generates RouterOS scripts for each device and deploys them to the router.
Loads configuration from .env files (multi-level support).
"""

import json
import os
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List


def load_env_file(filepath: Path) -> dict[str, str]:
  """Load environment variables from a .env file."""
  env_vars = {}
  if not filepath.exists():
    return env_vars

  for line in filepath.read_text().splitlines():
    line = line.strip()
    # Skip empty lines and comments
    if not line or line.startswith("#"):
      continue
    # Parse KEY=VALUE
    if "=" in line:
      key, value = line.split("=", 1)
      env_vars[key.strip()] = value.strip()

  return env_vars


def load_config(source_dir: Path) -> dict[str, str]:
  """Load configuration from service .env file with environment variable overrides."""
  config = load_env_file(source_dir / ".env")

  # Environment variables override .env values
  for key in config:
    if key in os.environ:
      config[key] = os.environ[key]

  return config


SCRIPT_DIR = Path(__file__).resolve().parent
ROOT_DIR = SCRIPT_DIR.parent.parent
CONFIG = load_config(SCRIPT_DIR)

ROUTER_SSH_HOST = CONFIG["ROUTER_SSH_HOST"]
ROUTER_SSH_USER = CONFIG["ROUTER_SSH_USER"]
ROUTER_SSH_IDENTITY_FILE = CONFIG["ROUTER_SSH_IDENTITY_FILE"]
SCHEDULE_INTERVAL = CONFIG["SCHEDULE_INTERVAL"]
DOMAIN_SUFFIX = CONFIG["DOMAIN_SUFFIX"]

# Colors for output
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
NC = "\033[0m"  # No Color


def print_info(msg: str) -> None:
  """Print status message in blue"""
  print(f"{BLUE}► {NC} {msg}")


def print_success(msg: str) -> None:
  """Print success message in green"""
  print(f"{GREEN}✓ {NC} {msg}")


def print_warning(msg: str) -> None:
  """Print warning message in yellow to stderr"""
  print(f"{YELLOW}⚠ {NC} {msg}", file=sys.stderr)


def print_error(msg: str) -> None:
  """Print error message in red to stderr"""
  print(f"{RED}✗ {NC} {msg}", file=sys.stderr)


@dataclass
class Device:
  host: str
  primary_mac: str
  secondary_mac: str
  description: str


def load_devices(devices_file: Path) -> List[Device]:
  """Load devices from devices.json file."""

  if not devices_file.exists():
    print_error(f"devices.json not found at {devices_file}")
    return []

  try:
    data = json.loads(devices_file.read_text())
    devices: list[Device] = []

    for host, device_info in data.get("devices", {}).items():
      device = Device(
        host=host,
        primary_mac=device_info.get("primary_mac", ""),
        secondary_mac=device_info.get("secondary_mac", ""),
        description=device_info.get("description", ""),
      )
      devices.append(device)

    return devices
  except json.JSONDecodeError as e:
    print_error(f"Failed to parse devices.json: {e}")
    return []

  return devices


def escape_script(content: str) -> str:
  """
  Escape content for RouterOS script.
  RouterOS needs:
  1. Backslashes -> \\
  2. Quotes -> \"
  3. Dollar signs -> \\$
  4. Actual newlines -> \\n
  """
  # Order matters: backslashes first, then other escapes
  content = content.replace("\\", "\\\\")
  content = content.replace('"', '\\"')
  content = content.replace("$", "\\$")
  content = content.replace("\n", "\\n")
  return content


def run_ssh_command(
  hostname: str, command: str, identity_file: str = ""
) -> tuple[str, int]:
  """Run SSH command and return output and return code."""
  args = ["ssh", f"{hostname}"]
  if identity_file:
    args.extend(["-i", identity_file])
  args.extend(["-x", command])
  try:
    result = subprocess.run(
      args,
      capture_output=True,
      text=True,
      check=True,
    )
    return result.stdout, result.returncode
  except Exception as e:
    print_error(f"SSH command failed: {e}")
    return "", -1


def run_on_router(command: str) -> tuple[str, int]:
  return run_ssh_command(
    ROUTER_SSH_USER + "@" + ROUTER_SSH_HOST,
    command,
    identity_file=ROUTER_SSH_IDENTITY_FILE,
  )


def upload_script(script_name: str, local_source: str, script_comment: str) -> bool:
  """Upload script to router."""
  print_info(f"Updating script '{script_name}' on {ROUTER_SSH_HOST}...")
  escaped_source = escape_script(local_source)

  # Remove old script
  run_on_router(f'/system script remove [find name="{script_name}"]')

  # Add new script
  run_on_router(
    f'/system script add name="{script_name}" source="{escaped_source}" comment="{script_comment}"',
  )
  print_success(f"Script '{script_name}' updated successfully")
  return True


def create_schedule(script_name: str, schedule_spec: str, user="admin") -> bool:
  """Set up a scheduler entry to run the script."""
  # Validate format: hh:mm:ss
  parts = schedule_spec.split(":")
  if len(parts) != 3:
    print_error(
      f"Invalid schedule format: '{schedule_spec}'. Expected hh:mm:ss (e.g., '00:05:00')"
    )
    return False

  try:
    hours = int(parts[0])
    minutes = int(parts[1])
    seconds = int(parts[2])
    if not (0 <= hours <= 23 and 0 <= minutes <= 59 and 0 <= seconds <= 59):
      raise ValueError()
  except (ValueError, IndexError):
    print_error(
      f"Invalid schedule format: '{schedule_spec}'. Hours must be 0-23, minutes 0-59, seconds 0-59"
    )
    return False

  schedule_name = f"{script_name}_schedule"

  # Remove existing schedule if it exists
  run_on_router(f'/system scheduler remove [find name="{schedule_name}"]')

  # Add new schedule
  run_on_router(
    f'/system scheduler add name="{schedule_name}" on-event="/system script run \\"{script_name}\\"" interval="{schedule_spec}"',
  )

  return True


def generate_device_discovery_script(
  hostname: str, primary_mac: str, secondary_mac: str
) -> str:
  """Generate a RouterOS script for a single device."""
  script = f"""# Updates DNS entry for {hostname}
# Generated by {SCRIPT_DIR.name} service

:local hostname "{hostname}"
:local primaryMac "{primary_mac}"
:local secondaryMac "{secondary_mac}"

:local findReachableIp do={{
  # Try each MAC in order (earlier ones are more preferred)
  # Return the first reachable interface and its IP, or empty array if none are reachable
  :local macs $1
  :foreach mac in=$macs do={{
    :if ($mac != "") do={{
      :put "  Trying MAC $mac"
      :local leaseEntries [/ip dhcp-server lease find where active-mac-address=$mac]
      :if ([:len $leaseEntries] > 0) do={{
        :foreach leaseIndex in=$leaseEntries do={{
          :local lease [/ip dhcp-server lease get $leaseIndex]
          :local ip ($lease->"active-address")
          :put "    Pinging $ip"
          :local pingResult [/ping $ip count=1]
          :if ($pingResult > 0) do={{
            :put "    Ping succeeded"
            :return {{$ip; $mac}}
          }} else={{
            :put "    Ping failed"
          }}
        }}
      }} else={{
        :put "    No active DHCP lease found"
      }}
    }}
  }}
  :put "  No reachable address found"
  :return ""
}}

:local updateDnsEntry do={{
  :local hostname $1
  :local ip $2
  :local mac $3
  
  /ip dns static remove [find name=$hostname]
  /ip dns static add name=$hostname address=$ip comment="$mac [MHS]" ttl=5m
  :put "  DNS updated: $hostname -> $ip"
}}

:put "==== Discovering $hostname ===="

:local macs {{$primaryMac; $secondaryMac}}
:local result [$findReachableIp $macs]

:if ($result != "") do={{
  :local ip ($result->0)
  :local mac ($result->1)
  :put "Using IP $ip (MAC: $mac)"
  [$updateDnsEntry $hostname $ip $mac]
}} else={{
  :put "ERROR: Could not find reachable IP for $hostname"
}}

:put "==== Complete ===="
"""
  return script


def main(argv: List[str] | None = None) -> None:
  """Main entry point."""

  device_scripts_dir = SCRIPT_DIR / "device-scripts"
  device_scripts_dir.mkdir(exist_ok=True)

  print_info("Deploying device discovery scripts...")
  print_info(f"Using router SSH host: {ROUTER_SSH_HOST}")
  print_info(f"Using schedule interval: {SCHEDULE_INTERVAL}")

  # Load devices from JSON in root directory
  devices_json_file = ROOT_DIR / "devices.json"
  devices = load_devices(devices_json_file)

  if not devices:
    print_error("No devices configured in devices.json")
    sys.exit(1)

  deployed_count = 0
  failed_count = 0

  for device in devices:
    name = device.description.strip() or device.host
    print_info(f"Processing {name}")

    script_name = f"discover-{device.host}"
    script_file = device_scripts_dir / f"{script_name}.rsc"
    script_comment = f"Discovery script for {name}"

    # Generate the RouterOS script
    routeros_script = generate_device_discovery_script(
      device.host + "." + DOMAIN_SUFFIX,
      device.primary_mac,
      device.secondary_mac,
    )

    try:
      script_file.write_text(routeros_script)
      print_info(f"Generated script: {script_name}.rsc")
    except Exception as e:
      print_error(f"Failed to generate script for {name}: {e}")
      failed_count += 1
      continue

    # Deploy the script to the router
    if upload_script(script_name, routeros_script, script_comment):
      if create_schedule(script_name, SCHEDULE_INTERVAL):
        print_success(f"Deployed {script_name} to {ROUTER_SSH_HOST}")
        deployed_count += 1
      else:
        print_error(f"Failed to schedule {script_name}")
        failed_count += 1
    else:
      print_error(f"Failed to deploy {script_name}")
      failed_count += 1

  # Summary
  print()
  print_info("Deployment complete:")
  print_success(f"Deployed: {deployed_count} device(s)")
  if failed_count > 0:
    print_warning(f"Failed: {failed_count} device(s)")
    sys.exit(1)

  sys.exit(0)


if __name__ == "__main__":
  main()
