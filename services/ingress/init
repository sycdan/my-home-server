#!/bin/bash

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
ROOT_DIR="$( cd "$SCRIPT_DIR/../../" && pwd )"
source "$ROOT_DIR/lib/common.sh"
source "$ROOT_DIR/lib/services.sh"
source "$SCRIPT_DIR/lib/ensure-sbin-path.sh"

require_command "jq"
require_command "curl"
require_command "dig" "dnsutils"

DOMAINS_FILEPATH="${DOMAINS_FILEPATH:-~/my-home-server/domains.json}"
DOMAINS_FILEPATH="$(eval echo "$DOMAINS_FILEPATH")" # resolve ~ to home directory
if [[ ! -f "$DOMAINS_FILEPATH" ]]; then
	print_error "Domains config file not found: $DOMAINS_FILEPATH"
	exit 1
fi
echo "Using domains config file: $DOMAINS_FILEPATH"

source "$SCRIPT_DIR/lib/validate-porkbun-credentials.sh"

# Parse domains.json into a bash associative array (only keys)
declare -A CONFIG_DOMAINS
while IFS= read -r domain; do
	CONFIG_DOMAINS["$domain"]=1
done < <(jq -r 'keys[]' "$DOMAINS_FILEPATH")

# Show domains to be configured
echo ""
print_status "Configuring ingress domains..."
get_ingress_domains | while read -r domain; do
	if [[ -n "${CONFIG_DOMAINS[$domain]}" ]]; then
		echo "  - $domain"
	else
		print_warning "Domain $domain not found in $DOMAINS_FILEPATH, skipping."
	fi
done
echo ""

# Process each unique domain (filtered by domains.json)
while read -r DOMAIN; do
	[[ -z "$DOMAIN" ]] && continue
	if [[ -z "${CONFIG_DOMAINS[$DOMAIN]}" ]]; then
		print_warning "Skipping $DOMAIN (not in $DOMAINS_FILEPATH)"
		((skip_count++))
		continue
	fi

	print_status "Checking domain: $DOMAIN"

	# Check if domain is registered (once per domain)
	HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 5 "http://$DOMAIN" 2>/dev/null || echo "000")

	if ! [[ "$HTTP_STATUS" =~ ^[23] ]]; then
		print_warning "Domain $DOMAIN not registered (HTTP $HTTP_STATUS), skipping all services"
		((skip_count++))
		continue
	fi

	print_success "Domain $DOMAIN is registered"
	echo ""

	# Process all services for this domain
	for service in "${SERVICES[@]}"; do
		FULL_HOSTNAME="${service%%|*}"

		# Skip if not for this domain
		if [[ ! "$FULL_HOSTNAME" == *"$DOMAIN" ]]; then
			continue
		fi

		# Extract subdomain
		SUBDOMAIN=$(echo "$FULL_HOSTNAME" | sed "s/\.$DOMAIN$//")

		print_status "Setting up: $FULL_HOSTNAME -> $CNAME_TARGET"

		# Check if CNAME already exists
		EXISTING_CNAME=$(dig +short $FULL_HOSTNAME CNAME 2>/dev/null | head -1)
		if [[ "$EXISTING_CNAME" == "$CNAME_TARGET." ]]; then
			print_success "CNAME already configured: $FULL_HOSTNAME"
			((success_count++))
			continue
		fi

		# Create CNAME record via Porkbun API
		API_RESPONSE=$(curl -s -X POST "https://api.porkbun.com/api/json/v3/dns/create/$DOMAIN" \
			-H "Content-Type: application/json" \
			-d "{\n                \"apikey\": \"$PORKBUN_API_KEY\",\n                \"secretapikey\": \"$PORKBUN_SECRET_KEY\",\n                \"name\": \"$SUBDOMAIN\",\n                \"type\": \"CNAME\",\n                \"content\": \"$CNAME_TARGET\",\n                \"ttl\": \"300\"\n            }")

		if echo "$API_RESPONSE" | grep -q '"status":"SUCCESS"'; then
			print_success "CNAME created: $FULL_HOSTNAME"
			((success_count++))
		elif echo "$API_RESPONSE" | grep -q "Domain is not opted in to API access"; then
			print_error "Domain $DOMAIN is not opted in to API access"
			echo "  Enable at: https://porkbun.com/account/domainsSpeedy"
			((error_count++))
		else
			ERROR_MSG=$(echo "$API_RESPONSE" | grep -o '"message":"[^"]*' | cut -d'"' -f4)
			print_error "API error for $FULL_HOSTNAME: $ERROR_MSG"
			((error_count++))
		fi
	done
	echo ""
done < <(get_ingress_domains)

if [[ $error_count -gt 0 ]]; then
	print_warning "Some domains had errors. Check configuration and try again."
	exit 1
fi

echo ""
source "$SCRIPT_DIR/lib/configure-nginx.sh"

echo ""
print_success "Ingress setup complete!"