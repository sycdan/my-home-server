#!/usr/bin/env python

import argparse
import os
import subprocess
import sys
from pathlib import Path

# Colors for output
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
BLUE = "\033[0;34m"
NC = "\033[0m"  # No Color


def print_info(msg: str) -> None:
  """Print status message in blue"""
  print(f"{BLUE}► {NC} {msg}")


def print_success(msg: str) -> None:
  """Print success message in green"""
  print(f"{GREEN}✓ {NC} {msg}")


def print_warning(msg: str) -> None:
  """Print warning message in yellow to stderr"""
  print(f"{YELLOW}⚠ {NC} {msg}", file=sys.stderr)


def print_error(msg: str) -> None:
  """Print error message in red to stderr"""
  print(f"{RED}✗ {NC} {msg}", file=sys.stderr)


def escape_script(content: str) -> str:
  r"""
    Escape content for RouterOS script.
    RouterOS needs:
    1. Backslashes -> \\
    2. Quotes -> \"
    3. Dollar signs -> \$
    4. Newlines -> literal \n sequence
    """
  # Order matters: backslashes first, then other escapes
  content = content.replace("\\", "\\\\")
  content = content.replace('"', '\\"')
  content = content.replace("$", "\\$")
  content = content.replace("\n", "\\n")
  return content


def unescape_routeros_string(content: str) -> str:
  r"""Reverse the escaping done for RouterOS scripts"""
  # Reverse order from escape_routeros_string
  content = content.replace("\\n", "\n")
  content = content.replace('\\"', '"')
  content = content.replace("\\$", "$")
  content = content.replace("\\\\", "\\")
  return content


def run_ssh_command(host: str, command: str) -> tuple[str, int]:
  """Run SSH command and return output"""
  try:
    result = subprocess.run(
      ["ssh", host, "-x", command], capture_output=True, text=True, check=False
    )
    return result.stdout, result.returncode
  except Exception as e:
    return "", -1


def upload_script(
  host: str,
  script_name: str,
  local_source: str,
  script_comment: str,
  debug: bool = False,
) -> bool:
  """Upload script to router and return True if updated"""
  print_info(f"Updating script '{script_name}' on {host}...")
  escaped_source = escape_script(local_source)
  if debug:
    print_info("Escaped script source for RouterOS:")
    print(repr(escaped_source))
  run_ssh_command(host, f'/system script remove [find name="{script_name}"]')
  run_ssh_command(
    host,
    f'/system script add name="{script_name}" source="{escaped_source}" comment="{script_comment}"',
  )
  print_success(f"Script '{script_name}' updated successfully")
  return True


def create_schedule(host: str, script_name: str, schedule_spec: str) -> bool:
  """Set up a scheduler entry to run the script on a schedule"""
  # Validate format: hh:mm:ss
  parts = schedule_spec.split(":")
  if len(parts) != 3:
    print_error(
      f"Invalid schedule format: '{schedule_spec}'. Expected hh:mm:ss (e.g., '00:01:00')"
    )
    return False

  try:
    hours = int(parts[0])
    minutes = int(parts[1])
    seconds = int(parts[2])
    if not (0 <= hours <= 23 and 0 <= minutes <= 59 and 0 <= seconds <= 59):
      raise ValueError()
  except (ValueError, IndexError):
    print_error(
      f"Invalid schedule format: '{schedule_spec}'. Hours must be 0-23, minutes 0-59, seconds 0-59"
    )
    return False

  schedule_name = f"{script_name}_schedule"

  # Check if schedule already exists
  output, _ = run_ssh_command(
    host, f'/system scheduler print where name="{schedule_name}"'
  )

  # Remove existing schedule if it exists
  if output and "name=" in output:
    run_ssh_command(host, f'/system scheduler remove [find name="{schedule_name}"]')

  # Add new schedule
  run_ssh_command(
    host,
    f'/system scheduler add name="{schedule_name}" on-event="/system script run \\"{script_name}\\"" interval="{schedule_spec}"',
  )

  return True


def show_diff(remote: str, local: str) -> None:
  """Show diff between remote and local content"""
  try:
    import tempfile

    with tempfile.NamedTemporaryFile(
      mode="w", delete=False, suffix=".txt"
    ) as remote_temp:
      remote_temp.write(remote)
      remote_temp_path = remote_temp.name

    with tempfile.NamedTemporaryFile(
      mode="w", delete=False, suffix=".txt"
    ) as local_temp:
      local_temp.write(local)
      local_temp_path = local_temp.name

    subprocess.run(["diff", "-u", remote_temp_path, local_temp_path], check=False)

    os.unlink(remote_temp_path)
    os.unlink(local_temp_path)
  except Exception:
    pass


def main(argv: list[str] | None = None) -> None:
  parser = argparse.ArgumentParser(
    description="Deploy RouterOS scripts via SSH",
    formatter_class=argparse.RawDescriptionHelpFormatter,
  )
  parser.add_argument(
    "local_script_path",
    help="Path to the script file to deploy (the filename will be the script name on the remote)",
  )
  parser.add_argument(
    "--ssh-host",
    default="router",
    help="SSH host to connect to (default: router)",
  )
  parser.add_argument(
    "--run",
    action="store_true",
    help="Run the script immediately after deployment (even if it didn't change)",
  )
  parser.add_argument(
    "--schedule",
    metavar="INTERVAL",
    help="Set up a schedule to run the script (format: hh:mm:ss, e.g.: '00:01:00' for 1 minute)",
  )
  parser.add_argument(
    "--debug",
    action="store_true",
    help="Enable debug output",
  )

  args = parser.parse_args(argv)

  # Support both --debug flag and DEBUG environment variable
  debug = args.debug or os.environ.get("DEBUG", "0") == "1"

  local_script = Path(args.local_script_path)
  script_name = local_script.stem
  ssh_host = args.ssh_host
  run_script = args.run
  schedule = args.schedule

  if not local_script.is_file():
    print_error(f"Local script not found: {local_script.name}")
    sys.exit(1)

  print_info(f"Reading local script from {local_script.name}")
  local_source = local_script.read_text()

  # If the first line of the script is a comment, strip it off and use it as the comment on the remote
  if local_source.strip().startswith("#"):
    first_line, _, rest_of_script = local_source.partition("\n")
    script_comment = first_line.lstrip("#").strip()
    local_source = rest_of_script.strip() + "\n"
    if debug:
      print_info(f"Using script comment: '{script_comment}'")
  else:
    script_comment = str(local_script)

  print_info(f"Reading '{script_name}' script from router...")
  remote_script, returncode = run_ssh_command(
    ssh_host, f'{{:local s [/system script get "{script_name}" source]; :put $s}}'
  )
  remote_source = remote_script.strip() + "\n"
  if debug:
    print_info("Remote source:")
    print(repr(remote_source))

  # Check if update is needed
  if local_source != remote_source:
    print_warning(f"Script '{script_name}' needs to be updated")
    if debug:
      print_info("Showing diff (- = remote, + = local):")
      show_diff(remote_source, local_source)
    upload_script(ssh_host, script_name, local_source, script_comment, debug)
  else:
    print_info(f"Script '{script_name}' is already up to date")

  # Run the script if requested
  if run_script:
    print_info(f"Running script '{script_name}' on {ssh_host}...")
    output, _ = run_ssh_command(ssh_host, f'/system script run "{script_name}"')
    if output:
      print(output)
    print_success(f"Script '{script_name}' executed successfully")

  # Set up schedule if requested
  if schedule:
    print_info(
      f"Setting up schedule for script '{script_name}' with interval '{schedule}'..."
    )
    if create_schedule(ssh_host, script_name, schedule):
      print_success(f"Schedule '{script_name}_schedule' created successfully")
    else:
      print_warning(f"Failed to create schedule for '{script_name}'")

if __name__ == "__main__":
  main()
